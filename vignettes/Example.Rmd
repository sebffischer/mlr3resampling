<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Resampling examples}
-->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The goal of this vignette is to explain how to quantify the extent to
which it is possible to train on one data subset (say a geographic
region such as Europe), and predict on another data subset (say North
America). The ideas are similar to my previous blog posts about how to
do this in
[python](https://tdhock.github.io/blog/2022/generalization-to-new-subsets/) and
[R](https://tdhock.github.io/blog/2023/R-gen-new-subsets/).

### Simulated regression problems

Assume there is a data set with some rows from one person, some rows
from another,

```{r}
N <- 1000
library(data.table)
set.seed(1)
reg.dt <- data.table(
  x=runif(N, -2, 2),
  person=rep(1:2, each=0.5*N))
reg.pattern.list <- list(
  easy=function(x, person)x^2,
  impossible=function(x, person)(x^2+person*3)*(-1)^person)
reg.task.list <- list()
for(pattern in names(reg.pattern.list)){
  f <- reg.pattern.list[[pattern]]
  yname <- paste0("y_",pattern)
  reg.dt[, (yname) := f(x,person)+rnorm(N)][]
  task.dt <- reg.dt[, c("x","person",yname), with=FALSE]
  reg.task.list[[pattern]] <- mlr3::TaskRegr$new(
    pattern, task.dt, target=yname
  )$set_col_roles("person",c("group","stratum"))
}
reg.dt
```

The table above shows some simulated data for a regression problem.

```{r}
(reg.tall <- nc::capture_melt_single(
  reg.dt,
  pattern="easy|impossible",
  value.name="y"))
```

The table above is a more convenient form for visualization.

```{r}
library(ggplot2)
ggplot()+
  geom_point(aes(
    x, y),
    data=reg.tall)+
  facet_grid(
    pattern ~ person,
    labeller=label_both,
    space="free",
    scales="free")+
  scale_y_continuous(
    breaks=seq(-100, 100, by=2))
```

In the simulated data above, we can see that 
* for the easy pattern, it is the same for both people, so it should
  be possible/easy to train on one person, and accurately predict on
  another.
* for the impossible pattern, it is different for each person, so it
  should not be possible to train on one person, and accurately
  predict on another.

```{r}
same_other <- mlr3resampling::ResamplingSameOtherCV$new()
same_other$param_set$values$folds <- 3
reg.learner.list <- list(
  mlr3::LearnerRegrRpart$new(),
  mlr3::LearnerRegrFeatureless$new())
(bench.grid <- mlr3::benchmark_grid(
  reg.task.list,
  reg.learner.list,
  same_other))
bench.result <- mlr3::benchmark(bench.grid)
bench.score <- mlr3resampling::score(bench.result)

ggplot()+
  geom_point(aes(
    regr.mse, train.groups, color=algorithm),
    shape=1,
    data=bench.score)+
  facet_grid(
    person ~ task_id,
    labeller=label_both,
    scales="free")
```


### Simulated classification problems

Assume there is a data set with some rows from one person, some rows
from another,

```{r}
N <- 1000
library(data.table)
(full.dt <- data.table(
  label=factor(rep(c("spam","not spam"), l=N)),
  person=rep(1:2, each=0.5*N)
)[, signal := ifelse(label=="not spam", 0, 2)][])
```

Above each row has an person ID between 1 and 2. 
We can imagine a spam filtering system, that has training data for multiple people (here just two).
Each row in the table above represents a message which has been labeled as spam or not, by one of the two people.
Can we train on one person, and accurately predict on the other person?
To do that we will need some features, which we generate/simulate below:

```{r}
set.seed(1)
n.people <- length(unique(full.dt$person))
for(person.i in 1:n.people){
  use.signal.vec <- list(
    easy=rep(if(person.i==1)TRUE else FALSE, N),
    impossible=full.dt$person==person.i)
  for(feature.type in names(use.signal.vec)){
    use.signal <- use.signal.vec[[feature.type]]
    full.dt[
    , paste0("x",person.i,"_",feature.type) := ifelse(
      use.signal, signal, 0
    )+rnorm(N)][]
  }
}
full.dt
```

There are two sets of two features:

* For easy features, one is correlated with the label (`x1_easy`), and
  one is random noise (`x2_easy`), so the algorithm just needs to
  learn to ignore the noise feature, and concentrate on the signal
  feature. That should be possible given data from either person (same
  signal in each person).
* Each impossible feature is correlated with the label (when feature
  number same as person number), or is just noise (when person number
  different from feature number). So if the algorithm has access to
  the correct person (same as test, say person 2), then it needs to
  learn to use the corresponding feature `x2_impossible`. But if
  the algorithm does not have access to that person, then the best it
  can do is same as featureless (predict most frequent class label in
  train data).
  
### Visualization

Below we reshape the data to a table which is more suitable for visualization:

```{r}
(scatter.dt <- nc::capture_melt_multiple(
  full.dt,
  column="x[12]",
  "_",
  feature.type="easy|impossible"))
```

Below we visualize the pattern for each person and feature type:

```{r}
library(ggplot2)
ggplot()+
  geom_point(aes(
    x1, x2, color=label),
    shape=1,
    data=scatter.dt)+
  facet_grid(
    person ~ feature.type,
    labeller=label_both)
```

In the plot above, it is apparent that 

* for easy features (left), the two label classes differ in x1 values
  for both people. So it should be possible/easy to train on person 1, and
  predict accurately on person 2.
* for impossible features (right), the two people have different label
  patterns. For person 1, the two label classes differ in x1 values,
  whereas for person 2, the two label classes differ in x2 values. So
  it should be impossible to train on person 1, and predict accurately
  on person 2.

### Benchmark

```{r}
same_other <- mlr3resampling::ResamplingSameOtherCV$new()
same_other$param_set$values$folds <- 3
```


